<!DOCTYPE html>
<html>
  <head>
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"
    />
    <script src="../js/13/run_pprettify.js"></script>
    <link rel="stylesheet" href="../css/style.css" />
    <link rel="stylesheet" href="../css/pretty.css" />
  </head>

<body>
    <h2>具名函式/匿名函式</h2>

    <h2>Automatic Semicolon Insertion, ASI</h2>
    <p>
        JavaScript 的 ASI（Automatic Semicolon Insertion，自動插入分號）是一種 JavaScript 引擎用來在缺少分號的情況下，根據語法規則自動補充分號的機制。
        雖然在某些情況下自動插入分號可以幫助避免語法錯誤，但也可能導致意想不到的行為。因此，了解 ASI 的工作原理對於避免問題很有幫助。
    </p>
    <h3>自動插入分號的規則</h3>
    <h4>1.行尾結束時： 如果一行沒有分號並且該行語句結束，JavaScript 引擎會在行尾自動插入分號。</h4>
    <div  ><code ><span >let</span> x = <span >5</span>
    <span >let</span> y = <span >10</span>
    </code></div>
    <h4>這段代碼將被自動轉換為：</h4>
    <div  ><code ><span >let</span> x = <span >5</span>;
    <span >let</span> y = <span >10</span>;
</code></div>

    <h4>2.區塊結束時： 在區塊 {} 之後自動插入分號。</h4>
    <div  ><code ><span >function</span> <span >hello</span>(<span ></span>) {
    <span >return</span>
    {
      <span >message</span>: <span >"Hello"</span>
    }
  }
  </code></div>
    <h4>此代碼會被解釋為：</h4>
    <div  ><code ><span >function</span> <span >hello</span>(<span ></span>) {
    <span >return</span>;
    {
      <span >message</span>: <span >"Hello"</span>
    }
  }
  </code></div>

    <h4>這會導致返回 undefined，而不是預期的對象。</h4>


    <h4>3. 換行符號： 如果某個標識符或表達式之後出現換行，且該標識符不可能與後續語句合併為一個合法語法，則自動插入分號。</h4>
    <div  ><code ><span >return</span>
    <span >5</span> + <span >6</span>
    </code></div>
    <h4> 這將被解釋為：</h4>
    <div  ><code ><span >return</span>;
        <span >5</span> + <span >6</span>;
        </code></div>
    <h4>這會返回 undefined，而不是 11。</h4>


    <h3>可能引發問題的情況</h3>
    <h4>1. 自動換行插入： 使用 return、break、continue 等語句時，如果這些語句與下一行分開，JavaScript 可能會在不需要的地方插入分號，導致邏輯錯誤。<br>

        2. 避免單行函數： 像上面 return 的例子，應該避免這種單行函數的寫法，保證 return 和返回值在同一行。</h4>

    <p>
        結論:<br>
        雖然 ASI 可以讓開發者在某些情況下省略分號，但為了保證代碼的可讀性和避免潛在的陷阱，通常建議顯式地添加分號。
        **IDE通常會顯示**
    </p>

    <h2>原始型別/物件型別</h2>
    <h3>1. 原始型別（Primitive Types）</h3>
    <p>原始型別是最基本的數據類型，它們是不可變的（immutable），且直接存儲其值。JavaScript 中的原始型別共有 7 種：<br>
        原始型別列表：<br>
        string：表示字串，例如 "Hello"<br>
        number：表示數字，包括整數和浮點數，例如 42、3.14<br>
        bigint：表示任意精度的整數，例如 9007199254740991n<br>
        boolean：表示布爾值 true 或 false<br>
        undefined：當變數已聲明但尚未賦值時，其值是 undefined<br>
        null：表示空值，通常用來表示“無”的狀態<br>
        symbol：用來創建唯一的標識符，例如 Symbol("unique")<br>

        特點：<br>
        不可變性：原始型別的值不能被修改，任何對其值的操作都會生成新值，而不是修改原值。<br>
        按值傳遞：當將原始型別賦值或傳遞給變數時，是以值的方式傳遞，也就是說它們之間互相獨立。<br>
        範例：<br>
    </p>

    <div  ><code ><span >let</span> x = <span >10</span>;
    <span >let</span> y = x;  <span >// y 是 x 的複製，不受 x 的變化影響</span>
    x = <span >20</span>;
    <span >console</span>.<span >log</span>(y);  <span >// 輸出 10</span>
    </code></div>
    <p>在這裡，x 的修改不會影響 y，因為它們各自存儲了自己的值。</p>

    <h3>2. <strong>物件型別（Object Types）</strong></h3>
    <p>物件型別是由鍵值對組成的可變集合。所有非原始型別的數據都是物件型別，包括陣列、函數、日期等。</p>
    <h4>常見的物件型別：</h4>
    <ul>
        <li><strong>物件（Object）</strong>：包含鍵值對，例如 <code>{ name: "John", age: 30 }</code></li>
        <li><strong>陣列（Array）</strong>：一種特殊的物件，
            用來存儲有序的數據列表，例如 <code>[1, 2, 3]</code></li>
        <li><strong>函數（Function）</strong>：也是物件類型，可
            以作為一等公民進行操作，例如 <code>function add(a, b) { return a + b; }</code></li>
        <li><strong>日期（Date）</strong>：表示日
            期和時間的物件類型，例如 <code>new Date()</code></li>
        <li><strong>正則表達式（RegExp）</strong>：表示正則表達式的物
            件類型，例如 <code>/abc/</code></li>
    </ul>
    <h4>特點：</h4>
    <ul>
        <li><strong>可變性</strong>：物件型別的值是可變的，可以在原來的基礎上修改或擴展。</li>
        <li><strong>按參考傳遞</strong>：物件型別
            是按<strong>引用</strong>傳遞的，這意味著如果多個變數引用同一個物件，對其中一個變數所作的改變會影響到所有引用該物件的變數。</li>
    </ul>
    <h4>範例：</h4>
    <pre ><div ><div >javascript</div><div ><div ><div ><span  ><button ><svg      ></svg>複製程式碼</button></span></div></div></div><div  ><code ><span >let</span> obj1 = { <span >name</span>: <span >"Alice"</span> };
            <span >let</span> obj2 = obj1;  <span >// obj2 引用同一個物件</span>
            obj1.<span >name</span> = <span >"Bob"</span>;
            <span >console</span>.<span >log</span>(obj2.<span >name</span>);  <span >// 輸出 "Bob"</span>
            </code></div></div></pre>
    <p>在這裡，<code>obj1</code> 和 <code>obj2</code> 都引用了同一個物件，因此對 <code>obj1</code> 所做的修改會影響 <code>obj2</code>。</p>
    <h3>原始型別與物件型別的差異</h3>
    <table>
        <thead>
            <tr>
                <th>特性</th>
                <th>原始型別（Primitive Types）</th>
                <th>物件型別（Object Types）</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>可
                        變性</strong></td>
                <td>不可變，每次操作都返回新值</td>
                <td>可變，可以直接修改屬性和方法</td>
            </tr>
            <tr>
                <td><strong>比較方式</strong></td>
                <td>比較
                    值本身（按值比較）</td>
                <td>比較引用（按引用比較）</td>
            </tr>
            <tr>
                <td><strong>存儲方式</strong></td>
                <td>直接存儲其值</td>
                <td>存儲的是對象
                    的引用地址（指向內存位置）</td>
            </tr>
            <tr>
                <td><strong>傳遞方式</strong></td>
                <td>按值傳遞，每個變數互相獨立</td>
                <td>按引用傳遞，
                    變數間共享對象</td>
            </tr>
            <tr>
                <td><strong>類型數量</strong></td>
                <td>7 種：<code>string</code>, <code>number</code>, <code>boolean</code>, <code>bigint</code>,
                    <code>undefined</code>, <code>null</code>, <code>symbol</code></td>
                <td>無限數量
                    ，包含 <code>Object</code>、<code>Array</code>、<code>Function</code> 等</td>
            </tr>
        </tbody>
    </table>
    <h3>小結：</h3>
    <ul>
        <li><strong>原始型別</strong>：是簡單且不可變的數據類型，按值存儲和傳遞，適合處理基本的數據。</li>
        <li><strong>物件型別</strong>：是複雜且
            可變的數據類型，按引用存儲和傳遞，適合處理包含多個值的結構數據。</li>
    </ul>
    <p>這兩種型別的理解對於正確處理 JavaScript 中的數據結構至關重要，尤其是在變數賦值和比較時。</p>


    <h2>顯性轉換/隱性轉換</h2>
    <p>在 JavaScript 中，**顯性轉換（Explicit Conversion）<strong>和</strong>隱性轉換（Implicit Conversion）**指的是將一種資料類型轉換為另一種的過程。
        這兩種轉換的區別在於轉換是否是由開發者主動進行，或者是由 JavaScript 引擎自動進行。</p>
    <h3>1. <strong>顯性轉換（Explicit Conversion）</strong></h3>
    <p>顯性轉換是指開發者<strong>主動</strong>使用內建方法或運算符來將一種類型轉換為另一種類型。這是一個清晰、可控的過程，開發者確切地知道何時進行轉換。</p>
    <h4>常見的隱性轉換情況：</h4>
    <p><strong>轉換為字串</strong>：</p>
    <li>使用 <code>String()</code> 函數或 <code>toString()</code> 方法將其他類型的數據轉換為字串。</li>
    <code ><span >let</span> num = <span >123</span>;
    <span >let</span> str = <span >String</span>(num);  <span >// "123"</span>
    <span >let</span> bool = <span >true</span>;
    <span >let</span> strBool = <span >String</span>(bool);  <span >// "true"</span>
    </code>
    <p> <strong>轉換為數字</strong> ":"</p>
    <li>使用 <code>Number()</code> 函數或一元 <code>+</code> 運算符來將其他類型的數據轉換為數字。</li>
    <code ><span >let</span> str = <span >"456"</span>;
    <span >let</span> num = <span >Number</span>(str);  <span >// 456</span>
    <span >let</span> bool = <span >false</span>;
    <span >let</span> numBool = <span >Number</span>(bool);  <span >// 0</span>
    </code>
    <p>或者使用 <code>+</code> 進行快速轉換：</p>
    <div  ><code ><span >let</span> str = <span >"789"</span>;
        <span >let</span> num = +str;  <span >// 789</span>
        </code></div>
    <p><strong>轉換為布爾值</strong>：</p>
    <ul>
        <li>使用 <code>Boolean()</code> 函數來將其他類型轉換為布爾值。</li>
    </ul>
    <div  ><code ><span >let</span> str = <span >"hello"</span>;
            <span >let</span> bool = <span >Boolean</span>(str);  <span >// true</span>
            <span >let</span> zero = <span >0</span>;
            <span >let</span> boolZero = <span >Boolean</span>(zero);  <span >// false</span>
            </code></div>

    <h4>顯性轉換範例：</h4>
    <div  ><code ><span >let</span> value = <span >"123"</span>;
                <span >let</span> num = <span >Number</span>(value);  <span >// 顯性轉換為數字 123</span>
                <span >console</span>.<span >log</span>(num);  <span >// 123</span>
                </code></div>

    <h3>2. <strong>隱性轉換（Implicit Conversion）</strong></h3>
    <p>隱性轉換是指 JavaScript 在進行某些運算或操作時<strong>自動</strong>將一種資料類型轉換為另一種，這通常發生在運算符處理不同類型的數據時。隱性轉換可能會導致一些意外行為，因此需要特別注意。</p>

    <h4>常見的隱性轉換情況：</h4>
    <ol>
        <li>
            <p><strong>字串與其他類型的相加</strong>：</p>
            <ul>
                <li>當一個字串與數字或其他類型相加時，JavaScript 會將其他類型轉換為字串進行拼接。</li>
            </ul>
            <pre ><div ><div >javascript</div><div ><div ><div ><span  ><button ><svg      ></svg>複製程式碼</button></span></div></div></div><div  ><code ><span >let</span> result = <span >"The answer is "</span> + <span >42</span>;  <span >// "The answer is 42"</span>
                    <span >let</span> result2 = <span >"The number is "</span> + <span >true</span>;  <span >// "The number is true"</span>
                    </code></div></div></pre>
        </li>
        <li>
            <p><strong>數字運算中的布爾值</strong>：</p>
            <ul>
                <li>當布爾值與數字進行運算時，<code>true</code> 被隱性轉換為 <code>1</code>，<code>false</code> 被轉換為 <code>0</code>。</li>
            </ul>
            <pre ><div ><div >javascript</div><div ><div ><div ><span  ><button ><svg      ></svg>複製程式碼</button></span></div></div></div><div  ><code ><span >let</span> sum = <span >true</span> + <span >2</span>;  <span >// 1 + 2 = 3</span>
                    <span >let</span> difference = <span >false</span> - <span >1</span>;  <span >// 0 - 1 = -1</span>
                    </code></div></div></pre>
        </li>
        <li>
            <p><strong>比較運算中的隱性轉換</strong>：</p>
            <ul>
                <li>當使用比較運算符（如 <code>==</code>）時，JavaScript 可能會將兩個不同類型的值轉換為相同的類型來進行比較（這就是 <code>==</code> 和
                    <code>===</code> 的區別所在）。</li>
            </ul>
            <pre ><div ><div >javascript</div><div ><div ><div ><span  ><button ><svg      ></svg>複製程式碼</button></span></div></div></div><div  ><code ><span >console</span>.<span >log</span>(<span >5</span> == <span >"5"</span>);  <span >// true （因為字串 "5" 被隱性轉換為數字 5）</span>
                    <span >console</span>.<span >log</span>(<span >null</span> == <span >undefined</span>);  <span >// true</span>
                    </code></div></div></pre>
        </li>
    </ol>
    <h4>隱性轉換範例：</h4>
    <div  ><code ><span >let</span> value = <span >"5"</span>;
                        <span >let</span> sum = value * <span >2</span>;  <span >// "5" 被隱性轉換為數字 5，結果是 10</span>
                        <span >console</span>.<span >log</span>(sum);  <span >// 10</span>
                        </code></div>

    <h3>隱性轉換的常見問題：</h3>
    <p>隱性轉換有時會導致一些意外的行為，特別是在進行比較和運算時。例如：</p>
    <ol>
        <li>
            <p><strong><code>+</code> 和 <code>-</code> 的不同處理</strong>：</p>
            <ul>
                <li>使用 <code>+</code> 時，如果其中一個操作數是字串，JavaScript 會將其他操作數轉換為字串進行拼接。</li>
            </ul>
            <pre ><div ><div >javascript</div><div ><div ><div ><span  ><button ><svg      ></svg>複製程式碼</button></span></div></div></div><div  ><code ><span >let</span> result = <span >"10"</span> + <span >1</span>;  <span >// "101" （數字被轉換為字串）</span>
                        </code></div></div></pre>
            <ul>
                <li>而使用 <code>-</code> 時，JavaScript 會將字串轉換為數字進行計算。</li>
            </ul>
            <pre ><div ><div >javascript</div><div ><div ><div ><span  ><button ><svg      ></svg>複製程式碼</button></span></div></div></div><div  ><code ><span >let</span> result = <span >"10"</span> - <span >1</span>;  <span >// 9 （字串 "10" 被轉換為數字）</span>
                        </code></div></div></pre>
        </li>
        <li>
            <p><strong>與 <code>==</code> 相關的意外</strong>：</p>
            <ul>
                <li>由於 <code>==</code> 會進行隱性轉換，因此會導致一些看似反直覺的結果。例如：</li>
            </ul>
            <pre ><div ><div >javascript</div><div ><div ><div ><span  ><button ><svg      ></svg>複製程式碼</button></span></div></div></div><div  ><code ><span >console</span>.<span >log</span>([] == <span >false</span>);  <span >// true</span>
                        <span >console</span>.<span >log</span>([] == <span >0</span>);  <span >// true</span>
                        <span >console</span>.<span >log</span>([<span >1</span>] == <span >true</span>);  <span >// true</span>
                        </code></div></div></pre>
        </li>
    </ol>

    <h3>顯性轉換 vs 隱性轉換：</h3>
    <table>
        <thead>
            <tr>
                <th>特點</th>
                <th>顯性轉換（Explicit Conversion）</th>
                <th>隱性轉換（Implicit Conversion）</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>誰發
                        起轉換</strong></td>
                <td>由開發者明確進行轉換</td>
                <td>由 JavaScript 引擎自動進行</td>
            </tr>
            <tr>
                <td><strong>控制程度</strong></td>
                <td>高，轉
                    換是明確的</td>
                <td>低，容易出現意外行為</td>
            </tr>
            <tr>
                <td><strong>可預測性</strong></td>
                <td>更加可預測和可靠</td>
                <td>可能導致意外或混淆</td>
            </tr>
            <tr>
                <td><strong>常見情況</strong></td>
                <td>使用 <code>String()</code>、<code>Nu
                            mber()</code> 等函數</td>
                <td>字串拼接、布爾值運算、比較運算</td>
            </tr>
        </tbody>
    </table>
    <h3>總結：</h3>
    <ul>
        <li><strong>顯性轉換</strong> 是開發者主動使用的轉換方式，適合在需要控制類型轉換時使用。</li>
        <li><strong>隱性轉換</strong> 是 JavaScript 自動進行的轉換，發生在運算或比較操作中，這種轉換可能會導致潛在的問題，特別是在類型不一致的情況下。</li>
    </ul>


    <h2>型別比較</h2>
    <p>在 JavaScript 中，型別比較（type comparison）是經常遇到的問題，因為 JavaScript 是動態型別語言，因此變數的型別可以在運行時期改變。
        JavaScript 提供了兩種主要的比較運算符：</p>

    <h4>寬鬆比較（Loose Equality）：==</h4>
    <h4>嚴格比較（Strict Equality）：===</h4>
    <p>這兩者在比較時有不同的行為，特別是在處理不同類型的數據時。</p>
    <h3>1.寬鬆比較（==）</h3>
    <p>使用 == 進行比較時，JavaScript 會嘗試在比較前進行類型轉換，這意味著即使變數的類型不同，也可能返回 true。<br>
        範例：</p>
    <div  ><code ><span >console</span>.<span >log</span>(<span >5</span> == <span >'5'</span>);  <span >// true</span>
            <span >console</span>.<span >log</span>(<span >0</span> == <span >false</span>); <span >// true</span>
            <span >console</span>.<span >log</span>(<span >null</span> == <span >undefined</span>); <span >// true</span>
            </code></div>

    <p>規則：<br>
        JavaScript 會自動將不同類型的數據轉換為相同類型再進行比較。<br>
        字符串和數字會轉換為數字比較。<br>
        null 和 undefined 被視為相等。<br>
        false 會被轉換為 0，true 會被轉換為 1。<br>

        問題：<br>
        由於自動型別轉換，這種比較有時會導致意想不到的結果。因此，通常不推薦使用。<br></p>

    <h3>2. 嚴格比較（===）</h3>
    <p>使用 === 進行比較時，JavaScript 會不進行類型轉換，這意味著變數的類型和值必須完全相同才能返回 true。<br>範例：</p>
    <div  ><code ><span >console</span>.<span >log</span>(<span >5</span> == <span >'5'</span>);  <span >// true</span>
        <span >console</span>.<span >log</span>(<span >0</span> == <span >false</span>); <span >// true</span>
        <span >console</span>.<span >log</span>(<span >null</span> == <span >undefined</span>); <span >// true</span>
        </code></div>
    <p>
        規則：<br>
        如果兩個值的類型不同，直接返回 false。<br>
        必須在類型和值都相等的情況下，才會返回 true。<br>
        優點：<br>
        避免自動型別轉換的混淆。<br>
        更加明確和可預測，適合大部分比較情境。<br>
    </p>
    <h3>3. 其他比較方法</h3>
    Object.is()<br>
    用於比較兩個值是否相同，與 === 大致相同，但處理一些特殊值（如 NaN 和 -0）的方式不同。<br>
    <div  ><code ><span >console</span>.<span >log</span>(<span >Object</span>.<span >is</span>(<span >NaN</span>, <span >NaN</span>));      <span >// true</span>
        <span >console</span>.<span >log</span>(<span >NaN</span> === <span >NaN</span>);              <span >// false</span>
        <span >console</span>.<span >log</span>(<span >Object</span>.<span >is</span>(+<span >0</span>, -<span >0</span>));        <span >// false</span>
        <span >console</span>.<span >log</span>(+<span >0</span> === -<span >0</span>);                <span >// true</span>
        </code></div>
    <h3>4. 使用場景</h3>
    <p>
        === 嚴格比較： 在大多數情況下，應該使用 ===，因為它更加安全和清晰。<br>
        == 寬鬆比較： 當你確實需要進行不同類型之間的比較，並且希望 JavaScript 自動進行類型轉換時，才考慮使用。</p>
    <h3>常見陷阱</h3>
    <p>null 和 undefined 在 == 下相等，但在 === 下不相等。<br>
        NaN 與任何值都不相等，包括它自己，所以比較 NaN 值時應使用 isNaN() 或 Object.is()。</p>
    <h3>總結</h3>
    <p>使用 === 進行嚴格比較可以避免 JavaScript 自動進行型別轉換時帶來的潛在錯誤。<br>
        == 可能會讓代碼更加簡潔，但會帶來一些難以預測的結果，使用時需謹慎。</p>
</body>

</html>